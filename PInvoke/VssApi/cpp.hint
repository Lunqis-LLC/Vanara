// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define DEFINE_COMP_ROLIST(prop, cFunc, iElem, gFunc, cElem) IReadOnlyList<Vanara::PInvoke::VssApi::IVssWMFiledesc^>^ CVssComponent::prop::get() { UINT c; Utils::ThrowIfFailed(pNative->cFunc(&c)); auto ret = gcnew List<iElem^>(); ::iElem* v; for (UINT i = 0; i < c; i++) { pNative->gFunc(i, &v); ret->Add(gcnew cElem(v)); } return ret; }
#define DEFINE_WRAPPER_STRING_PROP(prop, meth) virtual property String^ prop { String^ get() { SafeBSTR v; Utils::ThrowIfFailed(pNative->meth(&v)); return (String^)v; } }
#define DEFINE_WRAPPER_PROP(prop, rtype, gtype, meth) DEFINE_WRAPPER_PROPC(prop, rtype, gtype, meth, static_cast<rtype>)
#define DEFINE_WRAPPER_QI_PROP(prop, rtype, gtype, meth, qitf) virtual property rtype prop { rtype get() { SafeComPtr<qitf*> p = pNative; gtype v; Utils::ThrowIfFailed(p->meth(&v)); return static_cast<rtype>(v); } }
#define DEFINE_WRAPPER_STRING_GS_PROP(prop) virtual property String^ prop { String^ get() { SafeBSTR v; Utils::ThrowIfFailed(pNative->Get##prop(&v)); return (String^)v; } void set(String^ value) { SafeString v(value); Utils::ThrowIfFailed(pNative->Set##prop(v)); } }
#define DEFINE_WRAPPER_PROPC(prop, rtype, gtype, meth, conv) virtual property rtype prop { rtype get() { gtype v; Utils::ThrowIfFailed(pNative->meth(&v)); return conv(v); } }
#define DEFINE_WRAPPER_GS_PROP(prop, rtype, gtype) virtual property rtype prop { rtype get() { gtype v; Utils::ThrowIfFailed(pNative->Get##prop(&v)); return static_cast<rtype>(v); } void set(rtype value) { Utils::ThrowIfFailed(pNative->Set##prop(static_cast<gtype>(value))); } }
#define DEFINE_WRAPPER_STRING_QI_GS_PROP(prop, qitf) virtual property String^ prop { String^ get() { SafeComPtr<qitf*> p = pNative; SafeBSTR v; Utils::ThrowIfFailed(p->Get##prop(&v)); return (String^)v; } void set(String^ value) { SafeComPtr<qitf*> p = pNative; SafeString v(value); Utils::ThrowIfFailed(p->Set##prop(v)); } }
#define DEFINE_WRAPPER_STRING_QI_PROP(prop, meth, qitf) virtual property String^ prop { String^ get() { SafeComPtr<qitf*> p = pNative; SafeBSTR v; Utils::ThrowIfFailed(p->meth(&v)); return (String^)v; } }
#define DEFINE_WM_COMP_ROLIST(prop, itf, cfield, gfunc, cwrap) private: ListImplBase<itf^>^ f##prop; int Get##prop##Count() { RefreshInfo(); return pInfo->cfield; } itf^ Get##prop(int i) { ::itf* p; Utils::ThrowIfFailed(pNative->gfunc(i, &p)); return gcnew cwrap(p); } public: property IReadOnlyList<itf^>^ prop { virtual IReadOnlyList<itf^>^ get() { if (!f##prop) f##prop = gcnew ListImplBase<itf^>(gcnew GetCount(this, &CVssWMComponent::Get##prop##Count), gcnew GetValue<itf^>(this, &CVssWMComponent::Get##prop)); return f##prop; } }
#define mgd_cast(T, t) (T^)Marshal::GetObjectForIUnknown(IntPtr((void*)t));
#define DEFINE_BC_ROLIST(prop, itf, ref) private: ListImplBase<itf>^ f##prop; int Get##prop##Count() { UINT c; Utils::ThrowIfFailed(pNative->ref(&c)); return c; } public: property IReadOnlyList<itf>^ prop { virtual IReadOnlyList<itf>^ get() { if (!f##prop) f##prop = gcnew ListImplBase<itf>(gcnew GetCount(this, &CVssBackupComponents::Get##prop##Count), gcnew GetValue<itf>(this, &CVssBackupComponents::Get##prop)); return f##prop; } }
#define DEFINE_EWM_ROLIST(prop, itf, gfunc, cwrap, ref, cexp) private: ListImplBase<itf^>^ f##prop; int Get##prop##Count() { ref(); return cexp; } itf^ Get##prop(int i) { ::itf* p; Utils::ThrowIfFailed(pNative->gfunc(i, &p)); return gcnew cwrap(p); } public: property IReadOnlyList<itf^>^ prop { virtual IReadOnlyList<itf^>^ get() { if (!f##prop) f##prop = gcnew ListImplBase<itf^>(gcnew GetCount(this, &CVssExamineWriterMetadata::Get##prop##Count), gcnew GetValue<itf^>(this, &CVssExamineWriterMetadata::Get##prop)); return f##prop; } }
